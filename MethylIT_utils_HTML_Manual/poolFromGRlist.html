<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Methylation pool from a list of GRanges objects with...</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="/media/sf_D/MethylIT_HTML_Manual/R.css" />
</head><body>

<table width="100%" summary="page for poolFromGRlist {MethylIT}"><tr><td>poolFromGRlist {MethylIT}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Methylation pool from a list of GRanges objects with methylation read
counts</h2>

<h3>Description</h3>

<p>This function will build a GRanges methylation pool from a list
of GRanges objects
</p>


<h3>Usage</h3>

<pre>
poolFromGRlist(LR, stat = "sum", num.cores = 1, tasks = 0L,
  prob = FALSE, column = 1L, verbose = TRUE, ...)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>LR</code></td>
<td>
<p>list of GRanges objects to build a virtual individual (methylation
pool)</p>
</td></tr>
<tr valign="top"><td><code>stat</code></td>
<td>
<p>statistic used to estimate the methylation pool: row sum, row
mean or row median of methylated and unmethylated read counts across
individuals</p>
</td></tr>
<tr valign="top"><td><code>num.cores</code></td>
<td>
<p>The number of cores to use, i.e. at most how many child
processes will be run simultaneously (see bplapply function from
BiocParallel package).</p>
</td></tr>
<tr valign="top"><td><code>tasks</code></td>
<td>
<p>integer(1). The number of tasks per job. Value must be a scalar
integer &gt;= 0L. In this documentation a job is defined as a single call
to a function, such as bplapply, bpmapply etc. A task is the division of
the X argument into chunks. When tasks == 0 (default), X is divided as
evenly as possible over the number of workers (see MulticoreParam from
BiocParallel package).</p>
</td></tr>
<tr valign="top"><td><code>prob</code></td>
<td>
<p>Logic. Whether the variable for pooling is between 0 and 1 (a
probability), e.g., methylation levels. If TRUE, then Fisher's
transformation is applied, the row mean is computed for each cytosine
site and returned in the original measurement scale between 0 and 1 by
using the inverse of Fisher's transformation.</p>
</td></tr>
<tr valign="top"><td><code>column</code></td>
<td>
<p>If prob == TRUE, then the 'column' from the LR metacolumns
where the prob values are found must be provided. Otherwise, column = 1L.</p>
</td></tr>
<tr valign="top"><td><code>verbose</code></td>
<td>
<p>If TRUE, prints the function log to stdout</p>
</td></tr>
<tr valign="top"><td><code>...</code></td>
<td>
<p>Additional parameters for 'uniqueGRanges' function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The list of GRanges objects (LR) provided to build a virtual
methylome should be an output of the function 'readCounts2GRangesList' or
at least each GRanges must have the columns named &quot;mC&quot; and &quot;uC&quot;, for the
read counts of methylated and unmethylated cytosines, respectively.
</p>


<h3>Value</h3>

<p>A GRanges object
</p>


<h3>Examples</h3>

<pre>
gr1 &lt;- makeGRangesFromDataFrame(
    data.frame(chr = "chr1", start = 11:15, end = 11:15,
               strand = '*', mC = 1, uC = 1:5),
    keep.extra.columns = TRUE)
gr2 &lt;- makeGRangesFromDataFrame(
    data.frame(chr = "chr1", start = 11:15, end = 11:15,
               strand = '*', mC = 1, uC = 1:5),
    keep.extra.columns = TRUE)

answer &lt;- poolFromGRlist(list(gr1, gr2), stat = 'sum', verbose = FALSE)

</pre>

<hr /><div style="text-align: center;">[Package <em>MethylIT</em> version 0.3.1 ]</div>
</body></html>
