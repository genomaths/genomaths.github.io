<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Unique genomic ranges from a list of GRanges objects</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="/media/sf_D/<a href='https://genomaths.github.io/MethylIT_HTML_Manual/MethylIT_Manual.html'>MethylIT</a>_HTML_Manual/R.css" />
</head><body>

<table width="100%" summary="page for uniqueGRanges {<a href='https://genomaths.github.io/MethylIT_HTML_Manual/MethylIT_Manual.html'>MethylIT</a>}"><tr><td>uniqueGRanges {<a href='https://genomaths.github.io/MethylIT_HTML_Manual/MethylIT_Manual.html'>MethylIT</a>}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Unique genomic ranges from a list of GRanges objects</h2>

<h3>Description</h3>

<p>Build an unique GRanges object from a list of Granges objects.
</p>


<h3>Usage</h3>

<pre>
uniqueGRanges(ListOfGranges, ncols = NULL, columns = NULL,
  chromosomes = NULL, maxgap = -1L, minoverlap = 1L, missing = 0,
  type = c("any", "start", "end", "within", "equal"), select = c("all",
  "first", "last", "arbitrary"), ignore.strand = FALSE, num.cores = 1,
  tasks = 0L, verbose = TRUE)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>ListOfGranges</code></td>
<td>
<p>Objects to combine. A list of GRanges object or a
GRangesList object.</p>
</td></tr>
<tr valign="top"><td><code>ncols</code></td>
<td>
<p>integer. Number of columns to use from the meta-column of each
GRanges object. Default value: NULL. If NULL, all the columns (from
column 1 to ncols) from each GRanges will be present in the uniqueGRanges
output.</p>
</td></tr>
<tr valign="top"><td><code>columns</code></td>
<td>
<p>interger number(s) corresponding to the specific column(s) to
use from the meta-column of each GRanges. Default value: NULL. if
provided, the metacolumn from the uniqueGRanges output will contain the
specified columns.</p>
</td></tr>
<tr valign="top"><td><code>chromosomes</code></td>
<td>
<p>Chromosomes used Default value: NULL</p>
</td></tr>
<tr valign="top"><td><code>maxgap</code></td>
<td>
<p>See GenomicRanges::findOverlaps in the IRanges package for a
description of these arguments Default value: -1L</p>
</td></tr>
<tr valign="top"><td><code>minoverlap</code></td>
<td>
<p>See GenomicRanges::findOverlaps in the IRanges package for
a description of these arguments Default value: 1L</p>
</td></tr>
<tr valign="top"><td><code>missing</code></td>
<td>
<p>A numerical value (default 0) or NA to write in ranges with
missing values. For example, suppose that we want to build a
uniqueGRanges object from the GRanges objects X and Y. If a given range
k from the GRanges object X with metacolum value x is missing in the
GRanges object Y, then the metacolum of range k from
uniqueGRanges(list(X,Y)) object will be the row vector (x,0) or (x,NA)
if missing = NA.</p>
</td></tr>
<tr valign="top"><td><code>type</code></td>
<td>
<p>By default, any overlap is accepted. By specifying the type
parameter, one can select for specific types of overlap. The types
correspond to operations in Allen's Interval Algebra (see references).
If type is start or end, the intervals are required to have matching
starts or ends, respectively. While this operation seems trivial, the
naive implementation using outer would be much less efficient. Specifying
equal as the type returns the intersection of the start and end matches.
If  type is within, the query interval must be wholly contained within
the subject interval. Note that all matches must additionally satisfy the
minoverlap constraint described above. The maxgap parameter has special
meaning with the special overlap types. For start, end, and equal, it
specifies the maximum difference in the starts, ends or both,
respectively. For within, it is the maximum amount by which the subject
may be wider than the query.</p>
</td></tr>
<tr valign="top"><td><code>select</code></td>
<td>
<p>When select is &quot;all&quot; (the default), the results are returned as
a Hits object. Otherwise the returned value is an integer vector parallel
to query (i.e. same length) containing the first, last, or arbitrary
overlapping interval in subject, with NA indicating intervals that did
not overlap any intervals in subject.</p>
</td></tr>
<tr valign="top"><td><code>ignore.strand</code></td>
<td>
<p>When set to TRUE, the strand information is ignored in
the overlap calculations. Default value: TRUE</p>
</td></tr>
<tr valign="top"><td><code>num.cores</code></td>
<td>
<p>The number of cores to use, i.e. at most how many child
processes will be run simultaneously (see bplapply function from
BiocParallel package).</p>
</td></tr>
<tr valign="top"><td><code>tasks</code></td>
<td>
<p>integer(1). The number of tasks per job. value must be a scalar
integer &gt;= 0L. In this documentation a job is defined as a single call
to a function, such as bplapply, bpmapply etc. A task is the division of
the X argument into chunks. When tasks == 0 (default), X is divided as
evenly as possible over the number of workers (see MulticoreParam from
BiocParallel package).</p>
</td></tr>
<tr valign="top"><td><code>verbose</code></td>
<td>
<p>if TRUE, prints the function log to stdout</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The metadata of each one of these GRanges must have one or more
columns to yield a unique GRanges object with metadata columns from the
original GRanges objects. Otherwise, a unique GRanges object will be
created  without metadata columns. Additionally, all metadata must be the
same class, e.g. all numeric or all characters, or all factor
</p>


<h3>Value</h3>

<p>a GRanges object
</p>


<h3>Examples</h3>

<pre>
dfChr1 &lt;- data.frame(chr = "chr1", start = 11:15, end = 11:15,
                    strand = c("+","-","+","*","."), score = 1:5)
dfChr2 &lt;- data.frame(chr = "chr1", start = 11:15, end = 11:15,
                    strand = c("+","-","+","*","."), score = 1:5)
dfChr3 &lt;- data.frame(chr = "chr1", start = 11:15, end = 11:15,
                    strand = c("+","-","+","*","."), score = 1:5)

gr1 &lt;- makeGRangesFromDataFrame(dfChr1, keep.extra.columns = TRUE)
gr2 &lt;- makeGRangesFromDataFrame(dfChr2, keep.extra.columns = TRUE)
gr3 &lt;- makeGRangesFromDataFrame(dfChr3, keep.extra.columns = TRUE)

grList &lt;- GRangesList("gr1" = gr1, "gr2" = gr2, "gr3" = gr3)

uniqueGRanges(grList)

</pre>

<hr /><div style="text-align: center;">[Package <em><a href='https://genomaths.github.io/MethylIT_HTML_Manual/MethylIT_Manual.html'>MethylIT</a></em> version 0.3.1 ]</div>
</body></html>
