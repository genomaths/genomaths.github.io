---
title: "Methylation analysis based on signal detection"
subtitle: <h1>Optimal cutpoint estimation with [Methyl-IT](https://github.com/genomaths/MethylIT). 
           A guide for users</h>
author: |
 | Robersy Sanchez
 | rus547@psu.edu
 | Mackenzie's lab
 
 | Department of Biology and Plant Science. 
 | Pennsylvania State University, University Park, PA 16802
 | Maintainer: Robersy Sanchez
date: "`r format(Sys.time(), '%d %B %Y')`"
fontsize: 11pt
fontfamily: "serif"
bibliography: bibliography.bib
output:
  rmarkdown::html_document: 
    toc: true
    toc_depth: 3
    toc_float: 
      collapsed: false
      smooth_scroll: true
    number_sections: true
    highlight: tango
    theme: united
    geometry: margin=0.8in
    keep_md: yes
  
abstract: |
  The discrimination of the methylation signal from the stochastic methylation
  background resultant from the standard (non-stressful) biological processes is
  a critical step for the genome-wide methylation analysis. Such a
  discrimination requires for the knowledge of the probability distribution of
  the information divergence of methylation levels and a proper evaluation of
  the classification performance of differentially methylated positions (DMPs)
  into two classes: DMPs from control and DMPs from treatment.
  
---

<style type="text/css">

.list-group-item.active, .list-group-item.active:focus, 
.list-group-item.active:hover {
    z-index: 2;
    color: #fff;
    background-color: #337ab7;
    border-color: #337ab7;
}

.tocify-subheader .tocify-item {
  font-size: 0.80em;
  padding-left: 25px;
  text-indent: 0;
}

.tocify-header .tocify-item {
  font-size: 0.85em;
  padding-left: 20px;
  text-indent: 0;
}

body{ /* Normal  */
      font-size: 18px;
      font-family: "Times New Roman", Times, serif;
      text-align: justify
  }
td {  /* Table  */
  font-size: 8px;
}

h1.title {
  font-size: 38px;
  font-family: "Times New Roman", Times, serif;
  color: DarkRed;
  .subTitle {
  font-size: 24px;
  font-family: "Times New Roman", Times, serif;
  color: DarkRed;
  }
}

h1 { /* Header 1 */
  font-size: 28px;
  font-family: "Times New Roman", Times, serif;
  color: DarkBlue;
}
h2 { /* Header 2 */
    font-size: 22px;
    color: DarkBlue;
    font-family: "Times New Roman", Times, serif;
}
h3 { /* Header 3 */
   font-size: 18px;
   color: DarkBlue;
   font-family: "Times New Roman", Times, serif;
}
code.r{ /* Code block */
    font-size: 12px;
}
pre { /* Code block - determines code spacing between lines */
    font-size: 14px;
}
</style>

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
# Background
Normally, there is a spontaneous variability in the control group. This is a
consequence of the random fluctuations, or noise, inherent to the methylation
process. The stochasticity of the the methylation process derives from the
stochasticity inherent to biochemical processes. There are fundamental physical
reasons to acknowledge that biochemical processes are subject to noise and
fluctuations [@Samoilov2006; @Eldar2010]. So, regardless constant environment,
statistically significant methylation changes can be found in control population
with probability greater than zero and proportional to a Boltzmann factor
[@Sanchez2016].

Natural signals and those generated by human technology are not free of noise
and, as mentioned above, the methylation signal is no exception. Only signal
detection based approaches are designed to filter out the signal from the noise,
in natural and in human generated signals.

The need for the application of (what is now known as) signal detection in
cancer research was pointed out by Youden in the midst of the last century
[@Youden1950].
  
Note: This example was made with the MethylIT version 0.3.2 available at https://github.com/genomaths/MethylIT.  
It must NOT run with the current version 0.3.1 available at https://git.psu.edu/genomath/MethylIT
  

# Data generation
For the current example on methylation analysis with Methyl-IT we will use
simulated data. Read-count matrices of methylated and unmethylated cytosine are
generated with MethylIT.utils function *simulateCounts*. A standard analysis of this
dataset is given in the web page: [Methylation analysis with Methyl-IT](https://genomaths.github.io/Methylation_analysis_with_Methyl-IT.html)

```{r Exp-methlevel, include = TRUE, message = FALSE}
library(MethylIT)
library(MethylIT.utils)

bmean <- function(alpha, beta) alpha/(alpha + beta)
alpha.ct <- 0.09
alpha.tt <- 0.2

# The number of cytosine sites to generate
sites = 50000 
# Set a seed for pseudo-random number generation
set.seed(124)
control.nam <- c("C1", "C2", "C3")
treatment.nam <- c("T1", "T2", "T3")

# Reference group 
ref0 = simulateCounts(num.samples = 4, sites = sites, alpha = alpha.ct, beta = 0.5,
                      size = 50, theta = 4.5, sample.ids = c("R1", "R2", "R3"))
# Control group
ctrl = simulateCounts(num.samples = 3, sites = sites, alpha = alpha.ct, beta = 0.5,
                      size = 50, theta = 4.5, sample.ids = control.nam)
# Treatment group
treat = simulateCounts(num.samples = 3, sites = sites, alpha = alpha.tt, beta = 0.5,
                       size = 50, theta = 4.5, sample.ids = treatment.nam)

# Reference sample
ref = poolFromGRlist(ref0, stat = "mean", num.cores = 4L, verbose = FALSE)

# Methylation level divergences
DIVs <- estimateDivergence(ref = ref, indiv = c(ctrl, treat), Bayesian = TRUE, 
                           num.cores = 6L, percentile = 1, verbose = FALSE)
divs = DIVs[order(names(DIVs))]

# To remove hd == 0 to estimate. The methylation signal only is given for  
divs = lapply(divs, function(div) div[ abs(div$hdiv) > 0 ], keep.attr = TRUE)
names(divs) <- names(DIVs)

# Potential DMPs estimated with Fisher's exact Test (FT)
ft = FisherTest(LR = divs, tv.cut = 0.926, pAdjustMethod = "BH",
                     pvalCutOff = 0.05, num.cores = 4L,
                     verbose = FALSE, saveAll = FALSE) 

ft.tv <- getPotentialDIMP(LR = ft, div.col = 9L, dist.name = "None",
                          tv.cut = 0.926, tv.col = 7, alpha = 0.05)

# Potential DMPs estimated with 2-parameter gamma distribution model
nlms.g2p <- nonlinearFitDist(divs, column = 9L, verbose = FALSE, num.cores = 6L,
                            dist.name = "Gamma2P")
# Potential DMPs from 'Gamma2P' model
DMPs.g2p <- getPotentialDIMP(LR = divs, nlms = nlms.g2p,  div.col = 9L, 
                             tv.cut = 0.926, tv.col = 7, alpha = 0.05, 
                             dist.name = "Gamma2P")

```

To get some statistical description about the sample is useful. Here, empirical
critical values for the probability distribution of $H$ and $TV$ can is obtained
using *quantile* function from the R package *stats*.
```{r critical.val, include = TRUE}
critical.val <- do.call(rbind, lapply(divs, function(x) {
  x <- x[x$hdiv > 0]
  hd.95 = quantile(x$hdiv, 0.95)
  tv.95 = quantile(abs(x$TV), 0.95)
  return(c(tv = tv.95, hd = hd.95))
}))
critical.val

```

# Cutpoint for the spontaneous variability in the control group 
## Simple cutpoint estimation with classification performance evaluation for FT model

The simple cutpoint estimation available in Methyl-IT is based on the aplication 
of Youden index [@Youden1950]. Although cutpoints are estimated for a single variable,
the classification performance can be evaluated for several variables and appliying
different model classifiers 

In the current example, the column carrying *TV* (*div.col* = 7L) will be used
to estimate the cutpoint. The column values will be expressed in terms of
$TV_d=|p_{tt}-p_{ct}|$. A minimun cutpoint value for *TV* derived from the
minimum 95% quantile (*tv.cut* = 0.92) found in the treatment group will be
applied (see [Methylation analysis with
Methyl-IT](https://genomaths.github.io/Methylation_analysis_with_Methyl-IT.html)).

Next, a logistic model classifier will be fitted with the 60% (*prop* = 0.6)
of the raw data (training set) and then the resting 40% of individual samples
will be used to evaluate the model performance. The predictor variable included
in the model are specified with function parameter *column* (for more detail see [*estimateCutPoint*](https://genomaths.github.io/MethylIT_HTML_Manual/estimateCutPoint.html)
or type ?estimateCutPoint in R console).

```{r ft_cutpoint, include = TRUE}
# Cutpoint estimation for FT approach
cut.ft = estimateCutPoint(LR = ft.tv, simple = TRUE, 
                            column = c(hdiv = TRUE, TV = TRUE, 
                                       wprob = TRUE, pos = TRUE),
                            classifier1 = "logistic", 
                            interaction = "hdiv:wprob",
                            tv.cut = 0.926, 
                            control.names = control.nam,
                            treatment.names = treatment.nam,
                            clas.perf = TRUE, prop = 0.6, div.col = 7L)

cut.ft
summary(cut.ft$model)
```
As suggested in the above output, the classification performance of the logistic model 
on the training set is retrieved with expression:
```{r ft_cutpoint2, include = TRUE}
cut.ft$testSetPerformance
```
Notice that the low accuracy value reported here is mostly originated by
cytosine postitions found in the individual samples from control group that have
been predicted as treatment DMPs by FT test, but they are not from treatment. In
natural experimental samples, these DMPs (576 from the test-set) spontaneously
happend in the control group and they are not induced by the treatament.

In the current case, after the application of logistic model the classfication
performance improves a little bit, but this cannot solve the fundamental issue
derived from the FT classification.
```{r ft_cutpoint3, include = TRUE}
cut.ft$modelConfMatrix
```
## On Fisher's exact Test (FT) low classification performance
It seems to be that the poor classification performance from Fisher's exact Test (FT)
is due to variable $log_{10}(p.value)$, derived from FT, is not a good predictor.

```{r testing ft}
# Potential DMPs from 'Gamma2P' model
x <- ft
class(x) <- class(divs)
names(x) <- names(divs)

dmp.ft.g2p <- getPotentialDIMP(LR = x, nlms = nlms.g2p,  div.col = 9L,
                             tv.cut = 0.926, tv.col = 7, alpha = 0.5,
                             dist.name = "Gamma2P")

# Cutpoint estimation for FT approach
cutg2p = estimateCutPoint(LR = dmp.ft.g2p, simple = TRUE, 
                            column = c(hdiv = TRUE, TV = TRUE, 
                                       wprob = TRUE, pos = TRUE),
                            classifier1 = "logistic", 
                            interaction = "hdiv:wprob",
                            tv.cut = 0.926, 
                            control.names = control.nam,
                            treatment.names = treatment.nam,
                            clas.perf = TRUE, prop = 0.6, div.col = 9L)
c(cutpoint = cutg2p$cutpoint)
cutg2p$testSetPerformance
cutg2p$modelConfMatrix
```
Now with QDA classifier:
```{r testing ft2}
# Potential DMPs from 'Gamma2P' model
x <- ft
class(x) <- class(divs)
names(x) <- names(divs)

dmp.ft.g2p <- getPotentialDIMP(LR = x, nlms = nlms.g2p,  div.col = 9L,
                             tv.cut = 0.926, tv.col = 7, alpha = 0.5,
                             dist.name = "Gamma2P")

# Cutpoint estimation for FT approach
cutg2p = estimateCutPoint(LR = dmp.ft.g2p, simple = TRUE, 
                            column = c(hdiv = TRUE, TV = TRUE, 
                                       wprob = TRUE, pos = TRUE),
                            classifier1 = "qda", tv.cut = 0.926, 
                            control.names = control.nam,
                            treatment.names = treatment.nam,
                            clas.perf = TRUE, prop = 0.6, div.col = 9L)
c(cutpoint = cutg2p$cutpoint)
cutg2p$testSetPerformance
cutg2p$modelConfMatrix
```

After filtering the FT results with 2P gamma distribution
```{r, ft_g2p_filter}
rbind(ft = unlist(lapply(ft, function(x) length(x))),
  dmp.ft.g2p = unlist(lapply(dmp.ft.g2p, function(x) length(x))))
```


After the cutpoint application to select DMPs, a Monte Carlo (boostrap) analysis
reporting several classifier performance indicators can be accomplished by
using function
[*evaluateDIMPclass*](https://genomaths.github.io/MethylIT_HTML_Manual/evaluateDIMPclass.html)
and its settings *output = "mc.val"* and *num.boot*.
```{r ft_cutpoint4, include = TRUE}
ft.DMPs <- selectDIMP(dmp.ft.g2p, div.col = 7L, cutpoint = 0.98477, absolute = TRUE)
ft.class = evaluateDIMPclass(LR = ft.DMPs, 
                            column = c(hdiv = TRUE, TV = TRUE, 
                                       wprob = TRUE, pos = TRUE),
                            classifier = "logistic", 
                            interaction = "hdiv:wprob", 
                            control.names = control.nam,
                            treatment.names = treatment.nam, 
                            output = "mc.val", num.boot = 300, 
                            prop = 0.6)

ft.class
```
Notice that function *evaluateDIMPclass* uses function *estimateCutPoint* to estimate the cutpoint.
So, all the classification performance evaluation made by calling function *estimateCutPoint*
can be redone with function *evaluateDIMPclass*, and even to use different classifiers.

## Simple cutpoint estimation with classification performance evaluation for 2P gamma model
Here, we use the results of modeling the distribution of the Hellinger divergence (*HD*) of methylation levels 
through a 2-parameter gamma probability distribution model. The critical values for $HD_{\alpha = 0.05}^{CT_{G2P}}$ used to get potential DMPs were:

```{r}
nams <- names(nlms.g2p)
crit <- unlist(lapply(nlms.g2p, function(x) qgamma(0.95, shape = x$Estimate[1],
                                                   scale = x$Estimate[2])))
names(crit) <- nams
crit

```

As before the cutpoint is estimated based on 'Youden Index' [@Youden1950]. A
PCA+LDA model classifier (*classifier* = "pca.lda") is applied. That is, a
principal component analyis (PCA) is applied on the original raw matrix of data
and the four possible component (*n.pc* = 4) derived from the analysis are used
in a further linear discriminant analysis (LDA). A scaling step is applied to
the raw matrix of data before the application of the mentioned procedure
(*center* = TRUE, *scale* = TRUE). Here, PCA will yield new orthogonal
(non-correlated) variables, the principal components, which prevent any
potential bias effect originated by any correlation or association of the
original variables.

We can estimate the cutpoint, based on *HD* (*div.col* = 9L) or on 
$TV_d$ (*div.col* = 7L): 
```{r g2p_cutpoint, include = TRUE}
# Cutpoint estimation for the FT approach using the ECDF critical value
cut.g2p = estimateCutPoint(LR = DMPs.g2p, simple = TRUE,
                            column = c(hdiv = TRUE, TV = TRUE, 
                                       wprob = TRUE, pos = TRUE),
                            classifier1 = "pca.lda", n.pc = 4, 
                            tv.cut = 0.926, control.names = control.nam,
                            treatment.names = treatment.nam,
                            center = TRUE, scale = TRUE,
                            clas.perf = TRUE, prop = 0.6, div.col = 7L)
cut.g2p
```

As indicated above, the model classifier perfromance and its corresponding false
discovery rate can be retrieved as:
```{r g2p_cutpoint2, include = TRUE}
cut.g2p$testSetPerformance
cut.g2p$testSetModel.FDR
```

Next, a different model classifier can be applied to model the classification derived
from the previous cutpoint estimation and the evaluation of its performance can
be done (altoguether) with function
[evaluateDIMPclass](https://genomaths.github.io/MethylIT_HTML_Manual/evaluateDIMPclass.html)
Herein, the DMP classifiction is modelled with PCA+QDA classifier (*classifier* =
"pca.qda"). That is, principal component analyis (PCA) is applied on
the original raw matrix of data and the four possible component (*n.pc* = 4) are
used in a further quadratic discriminant analysis (QDA). A scaling step is
applied to the raw matrix of data before the application of the mentioned
procedure (*center* = TRUE, *scale* = TRUE).

```{r g2p_cutpoint3, include = TRUE}
g2p.DMPs <- selectDIMP(DMPs.g2p, div.col = 7L, cutpoint = 0.98477, absolute = TRUE)
g2p.class = evaluateDIMPclass(LR = g2p.DMPs, control.names = control.nam,
                           treatment.names = treatment.nam,
                           column = c(hdiv = TRUE, TV = TRUE, 
                                      wprob = TRUE, pos = TRUE),
                           classifier = "pca.qda", n.pc = 4, pval.col = 10L, 
                           center = TRUE, scale = TRUE,
                           output = "conf.mat", prop = 0.6
)
g2p.class
```
The model obtained can be used for futher prediction. For example, we would take a
random sample and run:
```{r}
set.seed(1)
randsampl <- unlist(DMPs.g2p)
randsampl <- randsampl[sample.int(length(randsampl), 10)]

pred <- predict(g2p.class$model, newdata = randsampl)
pred
```
The variable *pred$posterior* provides the posterior classification probabilities that
a DMP could belong to control (*CT*) or to treatment (*TT*) group. Notice that,
for each row, the sum of posterior probabilities is equal 1. By default, individuals with *TT*
posterior probabilities greater than 0.5 are predicted to belong to the treatment class. 
For example:
```{r pred}
classfiction = rep("CT", 10)
classfiction[pred$posterior[, 2] > 0.5] <- "TT"
classfiction
```
We can be more strict increasing the posterior classification probability cutoff
```{r pred2}
classfiction = rep("CT", 10)
classfiction[pred$posterior[, 2] > 0.7] <- "TT"
classfiction
```
In this case there is not change, but it could.

The model classifier can be evaluated on the whole dataset as well, before 
take potential DMPs.
```{r g2p_cutpoint4, include = TRUE}
g2p.class = evaluateDIMPclass(LR = DMPs.g2p, control.names = control.nam,
                           treatment.names = treatment.nam,
                           column = c(hdiv = TRUE, TV = TRUE, 
                                      wprob = TRUE, pos = TRUE),
                           classifier = "pca.qda", n.pc = 4, pval.col = 10L, 
                           center = TRUE, scale = TRUE,
                           output = "conf.mat", prop = 0.6
)
g2p.class
```

Classification performance results obtained with Monte Carlos sampling for the 
2P gamma model are quite different from those obtained with FT: 
```{r g2p_cutpoint5, include = TRUE}
g2p.class = evaluateDIMPclass(LR = DMPs.g2p, control.names = control.nam,
                           treatment.names = treatment.nam, 
                           column = c(hdiv = TRUE, TV = TRUE, 
                                      wprob = TRUE, pos = TRUE),
                           classifier = "pca.qda", n.pc = 4, pval.col = 10L, 
                           center = TRUE, scale = TRUE, num.boot = 300,
                           output = "mc.val", prop = 0.6
)
g2p.class
```

# To search for the best cutpoint
In the next example the cutpoint estimation for the Hellinger divergence of
methylation levels (*div.col* = 9L) is accomplished. Function *estimateCutPoint*
can be used to search for a cutpoint as well. Two model classifiers can be used.
*classifiers1* will be used to estimate the posterior classification
probabilities of DMP into those from control and those from treatment. These
probabilities are then used to estimate the cutpoint in the range of values
from, say, 0.5 to 0.8. Next, a *classifier2* will be used to evaluate the
classification performance. In this case, the search for an optimal cutpoin is
accomplished maximinzing the accuracy (*stat* = 0) of *classifier2*.

Below potential DMPs will be selected with probability alpha = 1 and then check whether 
the combination of model classifiers PCA+LDA is able to distinguish 
control DMPs from treataments. Notice that by setting alpha = 1 we are not 
using filtering the sample based on *p*-value and leaving the classifier to take
the decision on whether treatmetn DMPs can be distinguish from those detect in the
control sample. Here, we fundamentally rely on the strong *tv.cut*= 0.926 and on
the model probabilities:
```{r cutpoint_search, include = TRUE}
dmp.g2p <- getPotentialDIMP(LR = divs, nlms = nlms.g2p,  div.col = 9L, 
                             tv.cut = 0.926, tv.col = 7, alpha = 1, 
                             dist.name = "Gamma2P")

cut.g2p = estimateCutPoint(LR = dmp.g2p, simple = FALSE,
                            column = c(hdiv = TRUE, TV = TRUE, 
                                       wprob = TRUE, pos = TRUE),
                            classifier1 = "pca.lda", 
                            tv.cut = 0.92, stat = 0,
                            control.names = control.nam, 
                            treatment.names = treatment.nam, 
                            cut.values = seq(45, 114, 1), post.cut = 0.5,
                            clas.perf = TRUE, prop = 0.6,
                            center = TRUE, scale = TRUE,
                            n.pc = 4, div.col = 9L)
cut.g2p
```

The model classificaiton performance can be found as:
```{r cuts}
# Model performance in in the test dataset
cut.g2p$testSetPerformance

# Model performance in in the whole dataset
cut.g2p$modelConfMatrix

# The False discovery rate
cut.g2p$testSetModel.FDR

```
The model classifier *PCA+LDA* has enough discriminatory power to discriminate
control DMP from those induced by the treament for *HD* values
$55.064 < HD_{\alpha = 0.05}^{CT_{Emp}}=80.96 \le HD \le HD_{\alpha = 0.05}^{TT_{Emp}}=111.54$.


For the current dataset, we can try a more conservative cutpoint by alpha = 0.1 
when in the function *getPotentialDIMP*:
```{r cutpoint_search3, include = TRUE}
dmp.g2p <- getPotentialDIMP(LR = divs, nlms = nlms.g2p,  div.col = 9L,
                             tv.cut = 0.926, tv.col = 7, alpha = 0.1,
                             dist.name = "Gamma2P")

cut.g2p = estimateCutPoint(LR = dmp.g2p, simple = FALSE,
                            column = c(hdiv = TRUE, TV = TRUE, 
                                       wprob = TRUE, pos = TRUE),
                            classifier1 = "pca.lda", 
                            tv.cut = 0.926, stat = 0, post.cut = 0.5,
                            control.names = control.nam, 
                            treatment.names = treatment.nam, 
                            cut.values = seq(75, 114, 1), 
                            clas.perf = TRUE, prop = 0.6,
                            center = TRUE, scale = TRUE,
                            n.pc = 4, div.col = 9L)
cut.g2p
```

The probabilities $P(HD \le 81.6)$ to observe a cytosine site with $HD \le 81.6$ on each 
individual is:
```{r}
nams <- names(nlms.g2p)
crit <- unlist(lapply(nlms.g2p, function(x) pgamma(cut.g2p$cutpoint, shape = x$Estimate[1],
                                                   scale = x$Estimate[2])))
names(crit) <- nams
crit
```
The cutpoint for *HD* = 81.6 is lower than the lower critical values $HD_{\alpha = 0.05}^{Emp}=111.54$
estimated for treatment samples based on the empirical cumulative function, as shown above and in the previous
example: [Methylation analysis with Methyl-IT](https://genomaths.github.io/Methylation_analysis_with_Methyl-IT.html). 
But it is higher than the previous cutpoint with value 55.064 and there is not gain in classification performance. 

Notice that although the same *HD* value could be found in the same differentially
methylated cytosine site in control and treatment, if the probabilities
distributions of the information divergences from control and treatment are
diferent, then these DMPs can be distinguished.

```{r}
cut.g2p$testSetPerformance
```

# Conclusions 

1. A proper discrimination of the methylation signal from the stochastic
methylation background requires for the knowledge of probability distributions
of the methylation signal from control and treatment population. Such a
knowledge permits a suitable estimation of the cutoff value to discriminate the
methylation signal induced by the treatment from the stochastic methylation
background detected in the control group.   

2. It does not matter how significant a differentially methylation event for a
given cytosine position would be (after the application of some statistical
test), but on how big the probability to be oberved in the control group is. In
simple words, if for a given DMP the probability of to be oberved in the control
is *big enough*, then such a DMP did not result from a treatment effect.   

3. A suitable evaluation on how much the mentioned probability can be *big
enough* derives by estimating an optimal cutpoint. But a classification into two
groups results from the cutpoint estimation and the problem on the estimation of
such a cutpoint is equivalent to find a discriminatory function (as set by
Fisher, [@Fisher1938; @Green1979]). Cases with function values below some cutoff
are classified in one group, while values above the cutoff are put in the other
group.   

4. MethylIT function
[estimateCutPoint](https://genomaths.github.io/MethylIT_HTML_Manual/estimateCutPoint.html)
permits the estimation and search for an optimal cutpoint by confronting the
problem as in the spirit of the classical signal detection and as a
classification problem. The best model classifier will depend on the dataset
under study.So, uses must check for which is the model classifier with the best
classification performance for his/her dataset.

# References 













